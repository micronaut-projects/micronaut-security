IMPORTANT: The refresh token functionality has changed dramatically starting in Micronaut Security 2.0. Please read this section if you are upgrading as it now behaves differently.

Refresh tokens can be used to obtain a new access token. By default, refresh tokens are not generated.

To enable refresh token generation, you have to provide beans of type api:security.token.generator.RefreshTokenGenerator[],
api:security.token.validator.RefreshTokenValidator[] and api:security.token.refresh.RefreshTokenPersistence[].

The api:security.token.generator.RefreshTokenGenerator[] API is responsible for generating the token that gets included in the response.

api:io.micronaut.security.token.jwt.generator.SignedRefreshTokenGenerator[] an implementation of both api:security.token.generator.RefreshTokenGenerator[] and  api:security.token.validator.RefreshTokenValidator[] has been provided. It creates and verifies a JWS (JSON web signature) encoded object whose payload is a UUID with a hash-based message authentication code (HMAC). You can configure it:

include::{includedir}configurationProperties/io.micronaut.security.token.jwt.generator.RefreshTokenConfigurationProperties.adoc[]

To enable it you will need to provide a secret:

```yaml
micronaut:
    security:
        token:
            jwt:
                generator:
                    refresh-token:
                        secret: 'pleaseChangeThisSecretForANewOne'
```

After a token is generated, this library has no knowledge of it. The value is not cached or stored anywhere. It is up to each application to decide how to store the token, support revocation, and retrieve user details when given a token.

The api:security.token.refresh.RefreshTokenPersistence[] implementation will receive an event when refresh tokens is generated and then must persist the token along with a link to the user that it was generated for. The user information and the token are both available in the api:security.token.event.RefreshTokenGeneratedEvent[].

### Refreshing the Token

Micronaut security comes with a controller to allow for the refresh of access tokens. The api:security.token.jwt.endpoints.OauthController[controller] can be enabled with a configuration property.

include::{includedir}configurationProperties/io.micronaut.security.token.jwt.endpoints.OauthControllerConfigurationProperties.adoc[]

The controller exposes an endpoint as defined by https://tools.ietf.org/html/rfc6749#section-6[section 6 of the OAuth 2.0 spec] - Refreshing an Access Token.

The refresh token endpoint uses the api:security.token.validator.RefreshTokenValidator[] API to verify the token matches the format that is expected. api:io.micronaut.security.token.jwt.generator.SignedRefreshTokenGenerator[] attempts to verify the signature and returns the payload. Any validator implementations should not be concerned with revocation status, existence, or any other persistence related validation.

If the validator successfully validates the token, it is then passed to a api:security.token.refresh.RefreshTokenPersistence[] implementation, which each application must provide. A new access token is then created from the user details returned by `RefreshTokenPersistence::getUserDetails` and then sent in the response.

Here is an example of a refresh token request. Send a POST request to the `/oauth/access_token` endpoint:

[source,bash]
.Sample HTTP request to obtain an access token
----
POST /myApp/oauth/access_token HTTP/1.1
Host: micronaut.example
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ....
----

As you can see, is a form request with 2 parameters:

`grant_type`: must be `refresh_token` always.

`refresh_token`: the refresh token obtained previously.

TIP: Refresh tokens must be securely stored in your client application.
See https://tools.ietf.org/html/rfc6749#section-10.4[section 10.4 of the OAuth 2.0 spec] for more information.